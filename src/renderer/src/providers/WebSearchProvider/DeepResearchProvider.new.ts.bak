import { WebSearchProvider } from '@renderer/providers/WebSearchProvider/WebSearchProvider'
import { WebSearchResult } from '@renderer/types'

// 临时定义WebSearchState类型，因为它在@renderer/types中不存在
interface WebSearchState {
  defaultProvider: string
  providers: any[]
  maxResults: number
  excludeDomains: string[]
  searchWithTime: boolean
  subscribeSources: string[]
  overwrite: boolean
  deepResearchConfig?: {
    maxIterations?: number
    maxResultsPerQuery?: number
    autoSummary?: boolean
    enableQueryOptimization?: boolean
  }
}

// 临时定义DeepSearchProvider类
class DeepSearchProvider {
  constructor(provider: WebSearchProvider) {}

  async search(query: string, webSearchState?: WebSearchState, category?: string): Promise<{ results: WebSearchResult[] }> {
    return { results: [] }
  }
}

/**
 * 分析配置接口
 */
interface AnalysisConfig {
  maxIterations: number
  maxResultsPerQuery: number
  minConfidenceScore: number
  autoSummary: boolean
  modelId?: string
}

/**
 * 研究迭代接口
 */
interface ResearchIteration {
  query: string
  results: WebSearchResult[]
  analysis: string
  followUpQueries: string[]
}

/**
 * 研究报告接口
 */
export interface ResearchReport {
  originalQuery: string
  iterations: ResearchIteration[]
  summary: string
  keyInsights: string[]
  sources: string[]
}

/**
 * DeepResearchProvider 类
 * 提供深度研究功能，包括多轮搜索、分析和总结
 */
export class DeepResearchProvider {
  private deepSearchProvider: DeepSearchProvider
  private analysisConfig: AnalysisConfig
  constructor(provider: WebSearchProvider) {
    this.deepSearchProvider = new DeepSearchProvider(provider)
    this.analysisConfig = {
      maxIterations: 3, // 默认最大迭代次数
      maxResultsPerQuery: 20, // 每次查询的最大结果数
      minConfidenceScore: 0.6, // 最小可信度分数
      autoSummary: true // 自动生成摘要
    }
  }

  /**
   * 优化查询
   * @param query 用户原始查询
   * @returns 优化后的查询
   */
  private async optimizeQuery(query: string): Promise<string> {
    try {
      console.log(`[DeepResearch] 正在优化查询: "${query}"`)

      // 使用模型优化查询
      const { fetchGenerate } = await import('@renderer/services/ApiService')
      const prompt = `你是一个搜索优化专家，负责将用户的问题转化为最有效的搜索查询。

用户问题: "${query}"

请分析这个问题，并生成一个更有效的搜索查询。你的查询应该:
1. 提取关键概念和术语
2. 去除不必要的虚词和介词
3. 增加相关的同义词或专业术语(如果适用)
4. 保持简洁明确，不超过 10 个关键词

只返回优化后的查询词，不要添加任何解释或其他文本。`

      const optimizedQuery = await fetchGenerate({
        prompt,
        content: ' ', // 确保内容不为空
        modelId: this.analysisConfig.modelId
      })

      // 如果优化失败，返回原始查询
      if (!optimizedQuery || optimizedQuery.trim() === '') {
        return query
      }

      console.log(`[DeepResearch] 查询优化结果: "${optimizedQuery}"`)
      return optimizedQuery.trim()
    } catch (error) {
      console.error('[DeepResearch] 查询优化失败:', error)
      return query // 出错时返回原始查询
    }
  }

  /**
   * 执行深度研究
   * @param query 初始查询
   * @param websearch WebSearch状态
   * @returns 研究报告
   */
  public async research(query: string, websearch?: WebSearchState): Promise<ResearchReport> {
    // 确保 websearch 存在
    const webSearchState: WebSearchState = websearch || {
      defaultProvider: '',
      providers: [],
      maxResults: 10,
      excludeDomains: [],
      searchWithTime: false,
      subscribeSources: [],
      overwrite: false,
      deepResearchConfig: {
        maxIterations: this.analysisConfig.maxIterations,
        maxResultsPerQuery: this.analysisConfig.maxResultsPerQuery,
        autoSummary: this.analysisConfig.autoSummary || true
      }
    }
    console.log(`[DeepResearch] 开始深度研究: "${query}"`)

    // 根据配置决定是否优化查询
    let optimizedQuery = query
    if (webSearchState.deepResearchConfig?.enableQueryOptimization !== false) {
      console.log(`[DeepResearch] 启用查询优化`)
      optimizedQuery = await this.optimizeQuery(query)
    } else {
      console.log(`[DeepResearch] 未启用查询优化`)
    }

    const report: ResearchReport = {
      originalQuery: query,
      iterations: [],
      summary: '',
      keyInsights: [],
      sources: []
    }

    let currentQuery = optimizedQuery
    let iterationCount = 0
    const allSources = new Set<string>()

    // 定义搜索引擎类别列表
    const engineCategories = ['chinese', 'international', 'meta', 'academic']

    // 迭代研究过程
    while (iterationCount < this.analysisConfig.maxIterations) {
      console.log(`[DeepResearch] 迭代 ${iterationCount + 1}: "${currentQuery}"`)

      // 根据当前迭代选择搜索引擎类别
      const categoryIndex = iterationCount % engineCategories.length
      const currentCategory = engineCategories[categoryIndex]
      console.log(`[DeepResearch] 这一迭代使用 ${currentCategory} 类别的搜索引擎`)

      // 1. 使用DeepSearch获取当前查询的结果，指定搜索引擎类别
      const searchResponse = await this.deepSearchProvider.search(currentQuery, webSearchState, currentCategory)

      // 限制结果数量
      const limitedResults = searchResponse.results.slice(0, this.analysisConfig.maxResultsPerQuery)

      // 2. 分析搜索结果
      const analysis = await this.analyzeResults(limitedResults, currentQuery)

      // 3. 生成后续查询
      const followUpQueries = await this.generateFollowUpQueries(analysis, currentQuery, report.iterations)

      // 4. 记录这次迭代
      const iteration: ResearchIteration = {
        query: currentQuery,
        results: limitedResults,
        analysis,
        followUpQueries
      }

      report.iterations.push(iteration)

      // 5. 收集源
      limitedResults.forEach((result) => {
        if (result.url) {
          allSources.add(result.url)
        }
      })

      // 6. 检查是否继续迭代
      if (followUpQueries.length === 0) {
        console.log(`[DeepResearch] 没有更多的后续查询，结束迭代`)
        break
      }

      // 7. 更新查询并继续
      currentQuery = followUpQueries[0] // 使用第一个后续查询
      iterationCount++
    }

    // 生成最终总结
    report.summary = await this.generateSummary(report.iterations)
    report.keyInsights = await this.extractKeyInsights(report.iterations)
    report.sources = Array.from(allSources)

    console.log(`[DeepResearch] 完成深度研究，共 ${report.iterations.length} 次迭代`)
    return report
  }

  /**
   * 分析搜索结果
   * @param results 搜索结果
   * @param query 当前查询
   * @returns 分析文本
   */
  private async analyzeResults(results: WebSearchResult[], query: string): Promise<string> {
    if (results.length === 0) {
      return `没有找到关于"${query}"的相关信息。`
    }

    try {
      console.log(`[DeepResearch] 分析 ${results.length} 个结果`)

      // 提取关键信息
      const contentSummaries = results
        .map((result, index) => {
          const content = result.content || '无内容'
          // 提取前300个字符作为摘要
          const summary = content.length > 300 ? content.substring(0, 300) + '...' : content

          return `[${index + 1}] ${result.title}\n${summary}\n来源: ${result.url}\n`
        })
        .join('\n')

      // 使用模型分析内容
      const analysis = await this.analyzeWithModel(contentSummaries, query)

      return analysis
    } catch (error: any) {
      console.error('[DeepResearch] 分析结果时出错:', error)
      return `分析过程中出现错误: ${error?.message || '未知错误'}`
    }
  }

  /**
   * 使用项目中的模型分析搜索结果
   */
  private async analyzeWithModel(contentSummaries: string, query: string): Promise<string> {
    try {
      console.log(`[DeepResearch] 使用模型分析搜索结果`)

      // 分析提示词
      const prompt = `你是一个高级研究分析师，负责深入分析搜索结果并提取全面、详细的见解。
请对以下关于"${query}"的搜索结果进行彻底分析，并提供以下内容：

1. 主要发现（详细列出5-8个要点，每个要点至少包含3-4句解释）
2. 争议点或不同观点（详细分析各方观点及其依据）
3. 技术细节和实现方法（如适用）
4. 历史背景和发展脉络（如适用）
5. 最新进展和趋势
6. 专家共识和最佳实践
7. 需要进一步研究的领域（列出3-5个方向，并解释为什么这些方向值得探索）

请使用学术性、分析性的语言，提供深入的分析而非简单总结。确保你的分析：
- 包含具体的事实、数据和例子
- 引用搜索结果中的具体信息源
- 区分已确认的事实和推测性内容
- 指出信息的可靠性和局限性

搜索结果内容：
${contentSummaries}`

      // 检查内容是否为空
      if (!contentSummaries || contentSummaries.trim() === '') {
        return `没有找到关于"${query}"的有效内容可供分析。`
      }

      // 使用项目中的 fetchGenerate 函数调用模型
      const { fetchGenerate } = await import('@renderer/services/ApiService')
      const analysis = await fetchGenerate({
        prompt,
        content: contentSummaries || ' ', // 确保内容不为空
        modelId: this.analysisConfig.modelId // 使用指定的模型
      })

      return analysis || `分析失败，无法获取结果。`
    } catch (error: any) {
      console.error('[DeepResearch] 模型分析失败:', error)
      return `分析过程中出现错误: ${error?.message || '未知错误'}`
    }
  }

  /**
   * 生成后续查询
   * @param analysis 当前分析
   * @param currentQuery 当前查询
   * @param previousIterations 之前的迭代
   * @returns 后续查询列表
   */
  private async generateFollowUpQueries(
    analysis: string,
    currentQuery: string,
    previousIterations: ResearchIteration[]
  ): Promise<string[]> {
    try {
      // 避免重复查询
      const previousQueries = new Set(previousIterations.map((i) => i.query))
      previousQueries.add(currentQuery)

      // 使用模型生成后续查询
      const { fetchGenerate } = await import('@renderer/services/ApiService')
      const prompt = `你是一个研究助手，负责生成后续查询。
基于以下关于"${currentQuery}"的分析，生成 2-3 个后续查询，以深入探索该主题。

分析内容：
${analysis}

请仅返回查询列表，每行一个，不要添加编号或其他标记。确保查询简洁、具体且与原始查询"${currentQuery}"相关。`

      const result = await fetchGenerate({
        prompt,
        content: ' ', // 确保内容不为空
        modelId: this.analysisConfig.modelId // 使用指定的模型
      })

      if (!result) {
        return []
      }

      // 处理生成的查询
      const candidateQueries = result
        .split('\n')
        .map((q) => q.trim())
        .filter((q) => q.length > 0)

      // 过滤掉已经查询过的
      const newQueries = candidateQueries.filter((q) => !previousQueries.has(q))

      // 限制查询数量
      return newQueries.slice(0, 3)
    } catch (error: any) {
      console.error('[DeepResearch] 生成后续查询失败:', error)
      return []
    }
  }

  /**
   * 生成研究总结
   * @param iterations 所有迭代
   * @returns 总结文本
   */
  private async generateSummary(iterations: ResearchIteration[]): Promise<string> {
    if (iterations.length === 0) {
      return '没有足够的研究数据来生成总结。'
    }

    try {
      const mainQuery = iterations[0].query

      // 收集所有迭代的分析和查询
      const iterationsData = iterations
        .map((iter, index) => {
          return `迭代 ${index + 1}:\n查询: ${iter.query}\n分析:\n${iter.analysis}\n`
        })
        .join('\n---\n\n')

      // 使用模型生成总结
      const { fetchGenerate } = await import('@renderer/services/ApiService')
      const prompt = `你是一个研究助手，负责生成研究总结。
请基于以下关于"${mainQuery}"的多轮研究迭代，生成一份全面、深入的研究总结。

总结应包括：
1. 主要发现和见解
2. 不同观点或争议点
3. 该领域的当前状态
4. 未来发展趋势

请使用学术性、客观的语言，并确保总结涵盖所有迭代中的重要发现。

研究迭代数据：
${iterationsData}`

      // 确保内容不为空
      if (!iterationsData || iterationsData.trim() === '') {
        return `没有足够的数据来生成关于"${mainQuery}"的研究总结。`
      }

      const summary = await fetchGenerate({
        prompt,
        content: iterationsData || ' ', // 确保内容不为空
        modelId: this.analysisConfig.modelId // 使用指定的模型
      })

      return summary || `无法生成关于 "${mainQuery}" 的研究总结。`
    } catch (error: any) {
      console.error('[DeepResearch] 生成研究总结失败:', error)
      return `生成研究总结时出错: ${error?.message || '未知错误'}`
    }
  }

  /**
   * 提取关键见解
   * @param iterations 所有迭代
   * @returns 关键见解列表
   */
  private async extractKeyInsights(iterations: ResearchIteration[]): Promise<string[]> {
    if (iterations.length === 0) {
      return ['没有足够的研究数据来提取关键见解。']
    }

    try {
      const mainQuery = iterations[0].query

      // 收集所有迭代的分析
      const allAnalyses = iterations.map((iter) => iter.analysis).join('\n\n')

      // 使用模型提取关键见解
      const { fetchGenerate } = await import('@renderer/services/ApiService')
      const prompt = `你是一个研究助手，负责提取关键见解。
请从以下关于"${mainQuery}"的研究分析中，提取 4-6 条最重要的关键见解。

这些见解应该是研究中最有价值、最有洞察力的发现，能够帮助读者快速理解该主题的核心要点。

请仅返回见解列表，每行一条，不要添加编号或其他标记。确保每条见解简洁、清晰、有洞察力。

研究分析内容：
${allAnalyses}`

      // 确保内容不为空
      if (!allAnalyses || allAnalyses.trim() === '') {
        return [`关于${mainQuery}的研究数据不足，无法提取有意义的见解。`, `需要更多的搜索结果来全面分析${mainQuery}。`]
      }

      const result = await fetchGenerate({
        prompt,
        content: allAnalyses || ' ', // 确保内容不为空
        modelId: this.analysisConfig.modelId // 使用指定的模型
      })

      if (!result) {
        return [
          `${mainQuery}在多个领域都有重要应用。`,
          `关于${mainQuery}的研究在近年来呈上升趋势。`,
          `${mainQuery}的最佳实践尚未达成共识。`,
          `${mainQuery}的未来发展前景广阔。`
        ]
      }

      // 处理生成的见解
      return result
        .split('\n')
        .map((insight) => insight.trim())
        .filter((insight) => insight.length > 0)
    } catch (error: any) {
      console.error('[DeepResearch] 提取关键见解失败:', error)
      return [
        `${iterations[0].query}在多个领域都有重要应用。`,
        `关于${iterations[0].query}的研究在近年来呈上升趋势。`,
        `${iterations[0].query}的最佳实践尚未达成共识。`,
        `${iterations[0].query}的未来发展前景广阔。`
      ]
    }
  }

  /**
   * 设置分析配置
   * @param config 配置对象
   */
  public setAnalysisConfig(config: Partial<AnalysisConfig>): void {
    this.analysisConfig = {
      ...this.analysisConfig,
      ...config
    }
  }
}
